package hashtable

// 2732. 找到矩阵中的好子集
// 困难
// 提示
// 给你一个下标从 0 开始大小为 m x n 的二进制矩阵 grid 。
// 从原矩阵中选出若干行构成一个行的 非空 子集，如果子集中任何一列的和至多为子集大小的一半，那么我们称这个子集是 好子集。
// 更正式的，如果选出来的行子集大小（即行的数量）为 k，那么每一列的和至多为 floor(k / 2) 。
// 请你返回一个整数数组，它包含好子集的行下标，请你将子集中的元素 升序 返回。
// 如果有多个好子集，你可以返回任意一个。如果没有好子集，请你返回一个空数组。
// 一个矩阵 grid 的行 子集 ，是删除 grid 中某些（也可能不删除）行后，剩余行构成的元素集合。

// 示例 1：
// 输入：grid = [[0,1,1,0],[0,0,0,1],[1,1,1,1]]
// 输出：[0,1]
// 解释：我们可以选择第 0 和第 1 行构成一个好子集。
// 选出来的子集大小为 2 。
// - 第 0 列的和为 0 + 0 = 0 ，小于等于子集大小的一半。
// - 第 1 列的和为 1 + 0 = 1 ，小于等于子集大小的一半。
// - 第 2 列的和为 1 + 0 = 1 ，小于等于子集大小的一半。
// - 第 3 列的和为 0 + 1 = 1 ，小于等于子集大小的一半。

// 示例 2：
// 输入：grid = [[0]]
// 输出：[0]
// 解释：我们可以选择第 0 行构成一个好子集。
// 选出来的子集大小为 1 。
// - 第 0 列的和为 0 ，小于等于子集大小的一半。

// 示例 3：
// 输入：grid = [[1,1,1],[1,1,1]]
// 输出：[]
// 解释：没有办法得到一个好子集。

// 提示：
// m == grid.length
// n == grid[i].length
// 1 <= m <= 104
// 1 <= n <= 5
// grid[i][j] 要么是 0 ，要么是 1 。

func goodSubsetofBinaryMatrix(grid [][]int) []int {
	// 这题很难，因为要先证明只有1行或者2行。当然题目描述有这个提示
	// 剩下的就是利用位运算+二维的表去做与操作

	res := []int{}

	t := make(map[int]int)
	m := len(grid)
	n := len(grid[0])

	// 将 1 0 0 变成 001 塞到 e 上，然后作为 key，对应的行 i 作为 value
	for i := 0; i < m; i++ {
		e := 0
		for j := 0; j < n; j++ {
			e |= (grid[i][j] << j)
		}

		t[e] = i
	}

	// 如果 key 为 0，表示能找到全为 0 的一行
	if _, ok := t[0]; ok {
		res = append(res, t[0])
		return res
	}

	// 将 map 视为二维表，两两做与操作，为 0 表示符合条件
	for x, i := range t {
		for y, j := range t {
			if x&y == 0 {
				return []int{min(i, j), max(i, j)}
			}
		}
	}

	return res
}
